Success
    // 断点不见了 按 control + shift + r
    这节课是抠代码和补环境的衔接课程。所以课程中可能会用到一些补环境的思想。
    其实抠代码有时候是要适当的补一些环境的。

    为了避免翻车浪费大家时间，我把思路流程写成文档了，主打的就是稳健！

    首先：新手做法（经验不足）

    1. 首先第一步 确定函数入口。 由于它是一个 XHR请求，所以直接下 XHR断点，确定一下位置
    2. 确定位置：xhr.send(this.$_FIH.src.slice(151).split('&callback')[0])
    3. this.$_FIH.src.slice(151).split('&callback')[0] 就是参数位置。但是这里不是函数入口，因为不知道哪里来的。需要往前找
    4. 那么首先必须确定 this 是什么。 {
        拓展 1： this 指向了哪里？
        拓展 2： 确定原因后，如何进行定位
        拓展 3： 如何改变一个函数执行的this指向
    }
    5. 向上找一层堆栈，定位至  ----->   new yrx_lt(yrx_Z)
    6. 找前文，【谁调它】，找到 src: yrx_r，即 yrx_r 为生成的密文。下断
    7. 【这个时候就要开始思考了】yrx_r变量到底是哪来的 {
        方案 1： 向上硬读
        方案 2： 借助IDE
        方案 3： 看Scope找线索
    }
    8.  定位到 1443行 var yrx_i = yrx_t.$_Ds()[0][14]; 第一个参数 {
        选择 1： 断点打到函数第一行，即 var yrx_i = yrx_t.$_Ds()[0][14];
        选择 2： 直接看上一层堆栈
    }
    9.  断点打到 1443行 var yrx_i = yrx_t.$_Ds()[0][14] ，下断，向上一层看堆栈 定位 yrx_a
    10. 重复第七步，定位到 1256行 ，下断，向上看一层堆栈
    11. 定位到 1275行 yrx_e 是我们要找的对象。重复第七步
    12. 定位到 1249行 var yrx_C = yrx_t.$_Ds()[0][14];   第六个传入参数就是，向上一层看堆栈
    13. 定位到 1210行 yrx_i  重复第七步
    14. 定位到 1193行 var yrx_$ = yrx_t.$_CG, yrx_c = ["$_FIAV"].concat(yrx_$), yrx_s = yrx_c[1]; 下断
    15. yrx_i 就是，第三个传入的参数。 向上一层看堆栈
    16. yrx_c 就是，重复第七步（这步稍微有点长，得多向上看，咳咳，JS基础很重要嗷）
    17. 定位到1149行  var yrx_s = yrx_t.$_Ds()[0][14]; yrx_c就是，传入的第三个参数，向上看一层堆栈
    18. yrx_v 就是，重复第七步，定位到 5350行
    19. 函数入口基本确定： yrx_W[yrx_n(1303)](yrx_C) + yrx_$[yrx_n(1300)]()

    那么：逆向经验比较充足的人：
    XHR断点。向上找 15层堆栈。直接定位（每一层堆栈都看一下 Scope）


    接下来，我们尝试抠代码（其实用到了一定的补环境思路）

    在讲之前，我再稍微聊一下闭包的事儿（不深入，想深入看基础课）


    function a(b){
        return (function(){
            return (function(a, b, c){
                function d(){
                    return c + 6000; // 假装返回的是我们需要的关键密文
                }
                function e(){
                }
                console.log(d())
                document.createElement('canvas') // 假装进行样式渲染以及业务代码等不重要内容
            })(100, 1000, 10000)
        })(1, 2, 3)
    }
    a()

    我们可以对它进行一定的改造，把闭包的 d函数突到全局使用

    function a(b){
        return (function(){
            return (function(a, b, c){
                function d(){
                    return c + 6000; // 假装返回的是我们需要的关键密文
                }
                function e(){
                }
                window.yrx = d;
                document.createElement('canvas') // 假装进行样式渲染以及业务代码等不重要内容
                [0][1][2];
            })(100, 1000, 10000)
        })(1, 2, 3)
    }
    a()

    使用这个技巧是有严格限制条件的

        代码控制流必须走到全局变量吐出位置 即 window.yrx = d; （后面的就算报错也可以完全不管,不影响。 但是之前报错不行）

    PS：如果吐出位置之前有环境检测等各种检测的话，也没有办法绕过。它只是一种改变变量令其全局吐出的方法而已


    那么，现在，我们已经懂了这基础知识。我们开始操作上面的代码了

    为了让我们方便一些，我们使用  node --inspect-brk 去调试 node.js
    inspect我在基础课讲过了，这里再强调一次。 inspect是一个能够利用chrome浏览器调试 node.js 的工具。在node.js环境下，就可以进行舒服的调试。

    当然了，这个工具在打断点等这种方面，多少还是有一些弊端的。比如断点丢失之类的。也是没有办法的事情，不过不影响我们整体的调试。

    1. 首先，我们必须要稍微读一下js代码（不用细致的去读），看一下这些代码是否满足我们的条件，如果不满足的话。我们就得稍微处理一下，让它满足
    注意满足条件：让代码控制流走到我们要的位置相关函数就行，不用完全走完整个流程
    2. 该处理处理，该写死写死，该截断截断



        抠代码结业考试：
            把 yrx_W[yrx_n(1303)](yrx_C) + yrx_$[yrx_n(1300)]() 抠出来（不是用我的方式吐出来，而是~抠~出来）